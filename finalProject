#jordan's code
import random
from argparse import ArgumentParser
import sys
from time import sleep
import re

class Player:
    def __init__(self, player_name):
        self.name = player_name
        #would this go in gamestate since it's a single player game?
        self.guesses_made = []
        self.incorrect_guesses = 3
        self.points = 0
        self.word_guessed = False
        
    def turn(self, player):
        print(f"It is your turn, {self.player}!")
        guess = input("Guess a Letter, or guess the word")
        return guess
        self.guesses_made.append(guess)
        #need to do some sort of conditional expression, but need to make it work
        #i think i am having issues bc the turn and guesses code is so similar
        #self.word_guessed = True if guess == word else self.word_guessed = False
        
    #michael's code, im still working on these, my bad if they overlap w/ ur code
    def guess(word, jumble):
        #i think you might only need word param

    # convert both words to lowercase to ignore case sensitivity
        word = word.lower()
        jumble = jumble.lower()
    
    #create dictionaries to count the occurrences of each letter in both words
        word_count = {}
        jumble_count = {}
    
    #ount the occurrences of each letter in the word
        for letter in word:
            word_count[letter] = word_count.get(letter, 0) + 1
    
    #count the occurrences of each letter in the jumble
        for letter in jumble:
            jumble_count[letter] = jumble_count.get(letter, 0) + 1
    
    #check if the jumble contains all the letters required to form the word
        for letter, count in word_count.items():
            if letter not in jumble_count or jumble_count[letter] < count:
                return False


    #get the player's guess
        player_guess = input("Enter your guess: ")

# Doing this already in outcome.gameplay. Can this function just return 
# a scrambled word?
#check if the player's guess is correct
        attempts_left =3 
        if guess(word, player_guess):
            print("Yes, your guess is correct!")
        else:
            print("No, your guess is incorrect.")
            attempts_left -=1
        if attempts_left == 0:    
            return "No attempts left. Try again later."


    #will delete
    def guess_letter(theme, answer, letter, attempts_left):
        """
        Guess a letter in the word based on the given theme.
        
        Args:
        - theme: The theme of the word (string)
        - answer: The word the player is trying to guess (string).
        - letter: The letter guessed by the player (string)
        - attempts_left: The number of attempts the player has left (integer)
        
        Returns:
        - A string indicating whether the letter is correct or not.
        """
        if attempts_left <= 0:
            return "No attempts left. Try again later."
        
        if letter in answer:
            return "Correct!"
        else:
            attempts_left -= 1
            if attempts_left == 0:
                return "Incorrect. No attempts left."
            else:
                return f"Incorrect. Try again, {attempts_left} attempts left."
    ## stuff below is similar to michaels code above, will combine
        # if guess == word:
        #     self.guesses_made +=1
        #     print("You win!")
        # elif guess in word:
        #     self.guesses_made +=1
        #     print(f"{self.guess} is in the word!")
        #     #need to display how the guess shows up in the displayed word output
        # else:
        #     self.incorrect_guesses -= 1
        #     self.guesses_made +=1
        #     print("Not in our word/phrase. Your turn is over.")

#Ben's code
class GameState:
    def __init__(self, theme, random_word):
        self.theme = None
    def game_state(self):
        pass
    
    def get_theme(self, theme_choice):
        print("Possible themes: Fruit or Animals")
        theme_choice = input("Choose your theme")
        #raise value error if user doesn't input 'fruit' or 'animals'
        if theme_choice not in ["fruit", "animals"]:
            raise ValueError("Invalid theme.")
        #sets theme to input
        self.theme = theme_choice
        
    #ben's magic method
    
    #jordan will write a function to see if player wants to play again
    #will use conditional expression
    def play_again(self):
        play_again = input("Do you want to play the game again? Y/N: ")
        return True if play_again.upper() == "Y" else False
    #call main() if true and sys.exit() if false
    #then I think in main it will have to call this function at teh end to see if the program needs to be ran again



    def letters(self):
        letters1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
        random_letters = (random.choice(letters1), 3) 
        random_word += random_letters

    
    def scramble(self, random_word):
        shuffled_word = random.shuffle(random_word)

        print(shuffled_word)
        return shuffled_word
    
        
        

#luis' code
#new test
#is this supposed to be main, or can it be? if so, we should rename it to main and put it towards the end
#self, then self.theme? and this maybe main.
#ben will do a theme method 
def select_random_word(theme):
    file_path = f'{theme}_words.txt'
    with open(file_path, 'r') as file:
        words = [line.strip() for line in file]
    random_word = random.choice(words)

    return random_word
#gabrielle's code
#test
#note: we can prob do a repr at the end of this class for magic method points!
class Outcome:
    def __init__(self, word):
        self.score = 0
        self.word = word.lower()
        self.letter_dict = {
    'a': 3,
    'b': 2,
    'c': 1,
    'd': 1,
    'e': 3,
    'f': 2,
    'g': 2,
    'h': 1,
    'i': 3,
    'j': 5,
    'l': 3,
    'm': 2,
    'n': 2,
    'o': 5,
    'p': 2,
    'q': 5,
    'r': 2,
    's': 2, 
    't': 1,
    'u': 2,
    'v': 5,
    'w': 3,
    'x': 2,
    'y': 5,
    'z': 10
    }

    def __str__(self):
        self.calculatePotentialScore()
        print("The potential score for your word is: " + str(self.score) + " points.")
 
    def calculatePotentialScore(self):
        for i in self.word:
            self.score += self.letter_dict[i]
        return self.score

    def wordVerification(self, word):
        pattern = r"^[a-zA-Z]+$"
        if re.search(pattern, word):
            if len(word) < 4:
                bonus_points = 0
            else:
                bonus_points = len(word) % 2
            self.score += bonus_points
            return True
        else:
            print("Invalid Input Format. Please use only letters!")
            return False

    def results(self, guesses, answered, name="User"):
        if answered == 1:
            print("Congrats!" + str(name) + " got it correct!")
            print(str(name) + " recieved a score of " + str(self.score) + " with " + str(guesses) + " guesses remaining.")
        else:
            print(str(name) + " have run out of guesses and did not get the right answer!")
            print("Sorry " + str(name) + ", Please play again soon!")
                
#add parameter jumble word to gameplay
    def gameplay(self, word, guesses,name = "User"):
        self.__str__()

        # USE SCRAMBLE FUNCTION
        # PRINT SCAMBLED WORD
        # print("Here are your letters:" + str(scrambled_word))

        user_inp = input("What is your guess? \n")
        flag = False
        while not flag:
            sucess = self.wordVerification(user_inp)
            if sucess:
                flag = True
            else:
                user_inp = input("What is your guess? \n")
        answered = 0
        while guesses > 1 and answered == 0:
            if str(user_inp) == word:
                answered += 1
                break
            else:
                print("Incorrect guess. Try again!")
                guesses -= 1
                print("You have " + str(guesses) + " remaining.")
                user_inp = input("What is your next guess? \n")
                flag = False
                while not flag:
                    sucess = self.wordVerification(user_inp)
                    if sucess:
                        flag = True
                    else:
                        user_inp = input("What is your next guess? \n")
        self.results(guesses, answered, name)
        return guesses

#Jordan -- arg parse and if main
def parse_args(arglist):
   """parses the arguments and code given in our main() function

   Args:
       arglist (str): list of arguments to parse

   Returns:
       str: parsed arguments from those given
   """
   parser = ArgumentParser()
   parser.add_argument("theme", help = "Provide theme")
   return parser.parse_args(arglist)


if __name__ == "__main__":
   args = parse_args(sys.argv[1:])
   word = select_random_word(args.theme)
   name = input("Please enter your name: ")
   player1 = Player(name)
   bar = GameState(args.theme)
   running = Outcome(word)
   #add player.scramble or whatever scramble function is called in player
   GameState.scramble(random_word)
   running.gameplay(word, player1.incorrect_guesses, name)
